# -*- coding: utf-8 -*-
"""HCL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ycf9hcpbjcHSKihBydUMPR5wJ3njDBm4
"""

#unified product and inventory harmonization pipeline

import pandas as pd

inventory_snapshot_cols = [
    "snapshot_id",
    "snapshot_timestamp",
    "item_id",
    "product_id",
    "warehouse_id",
    "current_quantity",
    "available_quantity",
    "reserved_quantity",
    "damaged_quantity",
    "expired_quantity",
    "max_stock_capacity",
]

inventory_snapshot_df = pd.DataFrame(columns=inventory_snapshot_cols)
inventory_snapshot_df

restock_events_cols = [
    "restock_event_id",
    "restock_timestamp",
    "item_id",
    "product_id",
    "warehouse_id",
    "employee_id",
    "quantity_added",
    "source_location",
    "restock_type",
    "damaged_units_reported",
    "logical_max_quantity",
]

restock_events_df = pd.DataFrame(columns=restock_events_cols)
restock_events_df

inventory_snapshot_df["effective_stock_level"] = (
    inventory_snapshot_df["current_quantity"]
    + restock_events_df.groupby("item_id")["quantity_added"].transform("sum")
    - (inventory_snapshot_df["damaged_quantity"] + inventory_snapshot_df["expired_quantity"])
)

quarantine_inventory_df = pd.DataFrame()

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random


NUM_ITEMS = 10
NUM_WAREHOUSES = 3
DAYS = 5

np.random.seed(42)
random.seed(42)


def random_timestamp(day_index, base_date=datetime(2025,1,1)):
    """Generate a timestamp within a given day."""
    start = base_date + timedelta(days=day_index)
    hour = random.randint(6, 23)
    minute = random.randint(0, 59)
    return start.replace(hour=hour, minute=minute, second=0)


snapshot_records = []
restock_records = []


for item in range(1, NUM_ITEMS + 1):
    for wh in range(1, NUM_WAREHOUSES + 1):

        prev_quantity = random.randint(20, 40)
        last_restock_ts = None

        for day in range(DAYS):


            num_restocks_today = random.randint(0, 3)

            total_restock_added = 0
            restock_timestamps = []

            for _ in range(num_restocks_today):

                restock_ts = random_timestamp(day)
                restock_qty = random.randint(1, 10)
                damaged_units = random.randint(0, 2)

                restock_records.append({
                    "restock_event_id": f"RS_{item}_{wh}_{day}_{random.randint(1000,9999)}",
                    "restock_timestamp": restock_ts,
                    "item_id": item,
                    "product_id": f"P{item:03d}",
                    "warehouse_id": wh,
                    "employee_id": random.randint(101, 120),
                    "quantity_added": restock_qty,
                    "source_location": random.choice(["dock", "supplier_batch", "internal_transfer"]),
                    "restock_type": random.choice(["manual", "automated"]),
                    "damaged_units_reported": damaged_units,
                    "logical_max_quantity": 15
                })

                total_restock_added += restock_qty
                restock_timestamps.append(restock_ts)


            if restock_timestamps:
                snapshot_ts = max(restock_timestamps) + timedelta(minutes=random.randint(5, 60))
                last_restock_ts = max(restock_timestamps)
            else:

                snapshot_ts = random_timestamp(day)

            damaged = random.randint(0, 3)
            expired = random.randint(0, 1)

            new_quantity = prev_quantity + total_restock_added - damaged - expired
            new_quantity = max(new_quantity, 0)

            snapshot_records.append({
                "snapshot_id": f"SN_{item}_{wh}_{day}",
                "snapshot_timestamp": snapshot_ts,
                "item_id": item,
                "product_id": f"P{item:03d}",
                "warehouse_id": wh,
                "current_quantity": new_quantity,
                "available_quantity": new_quantity - random.randint(0, 2),
                "reserved_quantity": random.randint(0, 3),
                "damaged_quantity": damaged,
                "expired_quantity": expired,
                "max_stock_capacity": 100,
                "last_restock_timestamp": last_restock_ts
            })

            prev_quantity = new_quantity


inventory_snapshot_df = pd.DataFrame(snapshot_records).sort_values("snapshot_timestamp")
restock_events_df = pd.DataFrame(restock_records).sort_values("restock_timestamp")

inventory_snapshot_df.reset_index(drop=True, inplace=True)
restock_events_df.reset_index(drop=True, inplace=True)

inventory_snapshot_df.head()

restock_events_df.head()

neg_stock = inventory_snapshot_df[
    inventory_snapshot_df["current_quantity"] < 0
]

merged_pid = pd.merge(
    restock_events_df,
    inventory_snapshot_df,
    on=["item_id", "warehouse_id"],
    suffixes=("_rs", "_sn")
)

pid_mismatch = merged_pid[
    merged_pid["product_id_rs"] != merged_pid["product_id_sn"]
]

duplicates = inventory_snapshot_df[
    inventory_snapshot_df.duplicated(
        subset=["item_id", "warehouse_id", "snapshot_timestamp"],
        keep=False
    )
]

restock_exceeded = restock_events_df[
    restock_events_df["quantity_added"] > restock_events_df["logical_max_quantity"]
]

# join restocks with snapshots
rs_sn = pd.merge_asof(
    inventory_snapshot_df.sort_values("snapshot_timestamp"),
    restock_events_df.sort_values("restock_timestamp"),
    left_on="snapshot_timestamp",
    right_on="restock_timestamp",
    by=["item_id", "warehouse_id"],
    direction="backward"
)

rs_grouped = (
    restock_events_df.groupby(["item_id", "warehouse_id"])["quantity_added"]
    .sum()
    .reset_index()
    .rename(columns={"quantity_added":"total_restocked"})
)

snap_enriched = pd.merge(
    inventory_snapshot_df,
    rs_grouped,
    on=["item_id", "warehouse_id"],
    how="left"
).fillna({"total_restocked": 0})

snap_enriched["effective_stock_level"] = (
    snap_enriched["current_quantity"]
    + snap_enriched["total_restocked"]
    - (snap_enriched["damaged_quantity"] + snap_enriched["expired_quantity"])
)

quarantine_inventory = pd.concat([
    neg_stock,
    pid_mismatch,
    duplicates,
    restock_exceeded
], ignore_index=True).drop_duplicates()

inventory_fact_table = inventory_snapshot_df[
    ~inventory_snapshot_df["snapshot_id"].isin(quarantine_inventory["snapshot_id"].unique())
]

import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta

np.random.seed(42)
random.seed(42)

# ------------------------------------------
# Product Master for reference
# ------------------------------------------
product_master = pd.DataFrame({
    "product_id": ["P001", "P002", "P003", "P004"],
    "product_name": ["Apple Juice 1L", "Banana Chips", "Oreo Biscuit", "Detergent Powder"],
    "brand": ["Tropicana", "Haldirams", "Oreo", "Surf Excel"],
    "category": ["Beverage", "Snacks", "Snacks", "Cleaning"]
})

# ------------------------------------------
# Variants for names (simulate typos)
# ------------------------------------------
name_variants = {
    "Apple Juice 1L": ["Apple Jucie 1L", "Aple Juice", "Apple Juce 1000ml"],
    "Banana Chips": ["Bannana Chipz", "Banana Crisps", "Bananna Chps"],
    "Oreo Biscuit": ["Oreo Biskit", "Oriyo Biscuit", "Oreo Bisct"],
    "Detergent Powder": ["Deterjent Powder", "Detergent Pwd", "Dtrgent Powder"]
}

# ------------------------------------------
# Incorrect or missing product ids
# ------------------------------------------
bad_product_ids = [None, "PX12", "0001", "P1", " "]

warehouses = [1, 2, 3]
suppliers = ["SupplierA", "SupplierB", "DistributorX", "WholesalerY"]

incoming_records = []

for idx, row in product_master.iterrows():

    true_name = row["product_name"]
    variants = name_variants[true_name]

    for _ in range(5):  # generate 5 entries per product

        incoming_records.append({
            "incoming_id": f"INC_{idx}_{random.randint(1000,9999)}",
            "item_id": idx + 1,
            "product_id": random.choice(bad_product_ids),  # WRONG / MISSING
            "item_name": random.choice(variants),          # TYPO NAME
            "warehouse_id": random.choice(warehouses),
            "received_quantity": random.randint(5, 30),
            "received_timestamp": datetime(2025,1,1) + timedelta(days=random.randint(0,5)),
            "brand": row["brand"],
            "category": row["category"],
            "sku_raw": random.choice([f"P00{idx+1}", f"XX{idx+1}", f"SKU{idx+1}", None]),
            "supplier_name": random.choice(suppliers)
        })

incoming_inventory = pd.DataFrame(incoming_records)
incoming_inventory.head()

!pip install rapidfuzz

from rapidfuzz import fuzz, process
import re

def reconcile_product_id(row, product_master):

    # ---------------------------
    # 1. SKU PATTERN VALIDATION
    # ---------------------------
    valid_sku = False
    correct_sku_pattern = product_master["sku_pattern"].iloc[0]  # assume uniform pattern

    if pd.notna(row["product_id"]):
        valid_sku = bool(re.match(correct_sku_pattern, row["product_id"]))

    # ---------------------------
    # 2. If valid product_id â†’ return as is
    # ---------------------------
    if valid_sku:
        return row["product_id"], "valid", 1.0

    # ---------------------------
    # 3. FUZZY MATCH USING NAME
    # ---------------------------
    item_name = str(row["item_name"])
    candidates = product_master["product_name"].tolist()

    best_match, score, index = process.extractOne(
        item_name, candidates, scorer=fuzz.token_sort_ratio
    )

    suggested_pid = product_master.iloc[index]["product_id"]

    # ---------------------------
    # 4. Decision
    # ---------------------------
    status = "corrected" if score > 75 else "unresolved"

    return suggested_pid, status, score / 100

incoming_inventory["reconciled_product_id"] = None
incoming_inventory["recon_status"] = None
incoming_inventory["confidence"] = None

# Add 'sku_pattern' to product_master DataFrame to resolve KeyError
product_master["sku_pattern"] = "^P\\d{3}$"

for idx, row in incoming_inventory.iterrows():
    pid, status, conf = reconcile_product_id(row, product_master)
    incoming_inventory.at[idx, "reconciled_product_id"] = pid
    incoming_inventory.at[idx, "recon_status"] = status
    incoming_inventory.at[idx, "confidence"] = conf

incoming_inventory

